<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<title>Image annotator</title>

		<!-- Bootstrap -->
		<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap.min.css">
		<!-- Optional theme -->
		<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap-theme.min.css">
	<body>
		<header style="height:20px">
		</header>
		<center>

			<div>
				<h1>Hi, hello</h1>
			</div>

			<div>
				<! TODO:--- Hardcoded... get rid of it eventually-- Got rid -->
				<p class="lead" id="info-text">You are currently on frame 1 / 100</p>
			</div>
			<!--<div id="container">-->

				<!-- hidden canvas and image to conver images to matrices -->
				<!--
				<canvas id="hcanvas" width="640" height="400"></canvas>
				<canvas id="hcanvas2" width="640" height="400"></canvas> -->

				<div id="holder"></div>


			<div class="btn-group" role="group" aria-label="...">
				<button id="back_bttn" type="button" class="btn btn-default">
					<span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>
				</button>
				<button id="play_bttn" type="button" class="btn btn-default">
					<span class="glyphicon glyphicon-play" aria-hidden="true"></span>
				</button>
				<button id="pause_bttn" type="button" class="btn btn-default">
					<span class="glyphicon glyphicon-pause" aria-hidden="true"></span>
				</button>
				<button id="stop_bttn" type="button" class="btn btn-default">
					<span class="glyphicon glyphicon-stop" aria-hidden="true"></span>
				</button>
				<button id="fwd_bttn" type="button" class="btn btn-default">
					<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span>
				</button>

                <!-- Generate a random annotation
                    TODO: find a better button and place it a proper location-->
                <button id="gen_random_bttn" type="button" class="btn btn-default">
                    <span class="glyphicon glyphicon-plus" aria-hidden="true"></span>
                </button>

			</div>

			<!--
			<div id="holder"></div>
			-->

		</center>

		<!-- sprintf is super useful -->
		<script src="js/sprintf.min.js"></script>
		<!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
		<!-- Include all compiled plugins (below), or include individual files as needed -->
		<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/js/bootstrap.min.js"></script>

		<!-- optical flow -->
		<script src="js/oflow.js"></script>
		<!-- raphael-js for svg on canvas -->
		<script src="js/raphael-min.js"></script>
        <!-- Here we put all the controls --> 
		<script> 
 
    /* General Notes: 
        Note we take x as horizontal --- This has been the biggest confusion so far 
        for me working with images 
    attributes of annotation so far .. 
        img --- image
        flow
        data
            head        (head)
                x
                y
            body
                x
                y
            larm            //rats with hands !! scary
                x
                y
            rarm
                x
                y
            lleg
                x
                y
            rleg    
                x
                y
            tail
                x
                y
            mtail       (middle of tail)
                x
                y
    */          
        
    /* we move here because it do not simply works in another file*/
    // Global Variables
    var img_path   = 'imgs/undercam/cam1logfile1/cam1logfile1_%05d.jpeg';
    var flow_path  = 'flow/undercam/cam1logfile1/cam1logfile1_%05d.jpeg';
    var r;
    var nimages    = 100;       
    var play;                   // this is set to stop the playing when paused or stopped; a compulsion
    var current_image = 1;      // the image we are looking at
    var FPS = 10;               // Playing speed; TODO: Provide UI to change it
    var annotation = {};        // This should contain image, flow, as well as annotations (coordinates); 
                                // TODO: Define how should it contain  ---DONE
                                // This is all the data we need to save or should be caring about.
                                // Use of attributes seems the most plausible way
   
    // Have a variable to handle color of different datapoint and lines 
    
    // preload all the images and flow; To avoid lags
    for (i=0; i<nimages; i++) {
        annotation[i]           = [];
        annotation[i].img       = new Image();
        annotation[i].img.src   = sprintf( img_path, [i+1] );  // name of the image file.
        annotation[i].flow      = new Image();
        annotation[i].flow.src  = sprintf( flow_path, [i+1]);  // name of flow file
    }
        
    // create raphael element and show a fixed text
    r = Raphael("holder",annotation[0].img.width,annotation[0].img.height); 

    discattr    = {fill: "#fff", stroke: "none"};
    // Note we have to keep track of every svg element we create so that we can reorder it. 
    txt_element = r.text(310, 20, "drag the points to change the curves").attr({fill: "#fff", "font-size": 16});
    txt_element.toFront();
    // we don't need rectangle now... might need later
    //r.rect(0, 0, 640, 480, 0).attr({stroke: "#666"});
    
    // This function handles drawing of svg and dragging 
    // TODO: change it to handle a mouse

    function curve(keypoints, color) {
    // draw the lines in svg format.
        var path = [["M", keypoints.head.x, keypoints.head.y], 
                    ["L", keypoints.body.x, keypoints.body.y], 
                    ["L", keypoints.larm.x, keypoints.larm.y], 
                    ["M", keypoints.rarm.x, keypoints.rarm.y], 
                    ["L", keypoints.body.x, keypoints.body.y],
                    ["L", keypoints.tail.x, keypoints.tail.y], 
                    ["L", keypoints.lleg.x, keypoints.lleg.y], 
                    ["M", keypoints.rleg.x, keypoints.rleg.y], 
                    ["L", keypoints.tail.x, keypoints.tail.y], 
                    ["L", keypoints.mtail.x, keypoints.mtail.y]];
        curve = r.path(path).attr({stroke: color || raphael.getcolor(), "stroke-width": 4, "stroke-linecap": "round"});
        // curve.toFront();
        // draw the control points.
        controls = r.set(
            r.circle(keypoints.head.x, keypoints.head.y, 5).attr(discattr),
            r.circle(keypoints.body.x, keypoints.body.y, 5).attr(discattr),
            r.circle(keypoints.larm.x, keypoints.larm.y, 5).attr(discattr),
            r.circle(keypoints.rarm.x, keypoints.rarm.y, 5).attr(discattr),
            r.circle(keypoints.tail.x, keypoints.tail.y, 5).attr(discattr),
            r.circle(keypoints.lleg.x, keypoints.lleg.y, 5).attr(discattr),
            r.circle(keypoints.rleg.x, keypoints.rleg.y, 5).attr(discattr),
            r.circle(keypoints.mtail.x, keypoints.mtail.y, 5).attr(discattr)
        );
        
        // set control listeners for all the points.
        controls[0].update = function (x, y) {
            var X = this.attr("cx") + x, Y = this.attr("cy") + y;
            keypoints.head.x = X; keypoints.head.y = Y;
            this.attr({cx: X, cy: Y});
            path[0][1] = X; path[0][2] = Y;
            curve.attr({path: path});
            //console.log('X:' + X + " Y: " + Y);
        };
        controls[1].update = function (x, y) {
            var X = this.attr("cx") + x, Y = this.attr("cy") + y;
            keypoints.body.x = X; keypoints.body.y = Y
            this.attr({cx: X, cy: Y});
            path[1][1] = X; path[1][2] = Y;
            path[4][1] = X; path[4][2] = Y;
            curve.attr({path: path});
            //console.log('X:' + Y + " Y: " + Y);
        }; 
        controls[2].update = function (x, y) {
            var X = this.attr("cx") + x, Y = this.attr("cy") + y;
            keypoints.larm.x = X; keypoints.larm.y = Y
            this.attr({cx: X, cy: Y});
            path[2][1] = X; path[2][2] = Y;
            curve.attr({path: path});
            //console.log('X:' + X + " Y: " + Y);
        };
        controls[3].update = function (x, y) {
            var X = this.attr("cx") + x, Y = this.attr("cy") + y;
            keypoints.rarm.x = X; keypoints.rarm.y = Y
            this.attr({cx: X, cy: Y});
            path[3][1] = X; path[3][2] = X;
            curve.attr({path: path});
           // console.log('X:' + X + " Y: " + Y);
        }; 
        controls[4].update = function (x, y) {
            var X = this.attr("cx") + x, Y = this.attr("cy") + y;
            keypoints.tail.x = X; keypoints.tail.y = Y
            this.attr({cx: X, cy: Y});
            path[5][1] = X; path[5][2] = Y;
            path[8][1] = X; path[8][2] = Y;
            curve.attr({path: path});
            //console.log('X:' + X + " Y: " + Y);
        };
        controls[5].update = function (x, y) {
            var X = this.attr("cx") + x, Y = this.attr("cy") + y;
            keypoints.larm.x = X; keypoints.larm.y = Y    
            this.attr({cx: X, cy: Y});
            path[6][1] = X; path[6][2] = Y;
            curve.attr({path: path});
            //console.log('X:' + X + " Y: " + Y);
        };
        controls[6].update = function (x, y) {
            var X = this.attr("cx") + x, Y = this.attr("cy") + y;
            keypoints.rarm.x = X; keypoints.rarm.y = Y
            this.attr({cx: X, cy: Y});
            path[7][1] = X; path[7][2] = Y;
            curve.attr({path: path});
            //console.log('X:' + X + " Y: " + Y);
        };
        controls[7].update = function (x, y) {
            var X = this.attr("cx") + x, Y = this.attr("cy") + y;
            keypoints.mtail.x = X; keypoints.mtail.y = Y
            this.attr({cx: X, cy: Y});
            path[9][1] = X; path[9][2] = Y;
            curve.attr({path: path});
            //console.log('X:' + X + " Y: " + Y);
        };
        controls.drag(move, up);
    } // end curve

    function move(dx, dy) {
        this.update(dx - (this.dx || 0), dy - (this.dy || 0));
        this.dx = dx;
        this.dy = dy;
    }
        
    function up() {
        this.dx = this.dy = 0;
    }
    
    // updates the frame details
    function update_image() {
        img = annotation[current_image-1].img
        r.image(img.src,0,0,img.width,img.height);
        // since image should be background
        //    $('#to_annotate').attr('src', fname); // actually load the image.
        var new_text = sprintf('you are currently on frame %d / %d', current_image, nimages);
        $('#info-text').text( new_text ); // update the text at the top
    }

    // set frame no to frame_no
    function set_frame( frame_no ) {
        current_image  = frame_no;
        update_image();
    }

    // moves ahead by no_of_frame --- can take negative no. and go back
    function advance_frame(no_of_frame){
        var temp_current_image = current_image + no_of_frame;
        if (temp_current_image > nimages){
            current_image = nimages;
        }else if  (temp_current_image < 1){
            current_image = 1;
        }else{
            current_image = temp_current_image;
        }
        update_image();
        return ;
    }

    $('#fwd_bttn').click(function () {
        advance_frame(1);
    });

    //currently playing speed is set to 10fps
    $('#play_bttn').click(function () {
        $('#play_bttn').hide();
        $('#pause_bttn').show();
        play = window.setInterval(function() {
            advance_frame(1);
            if (current_image == nimages){
                window.clearInterval(play);
            }
            },100);
        });

    $('#pause_bttn').click(function () {
        $('#play_bttn').show();
        $('#pause_bttn').hide();
        window.clearInterval(play);
        });

    $('#stop_bttn').click(function () {
        window.clearInterval(play);
        $('#play_bttn').show();
        $('#pause_bttn').hide();
        set_frame(1);
        });

    $('#back_bttn').click( function() {
        advance_frame(-1);
    });

    $('#gen_random_bttn').click(function() {
        // generate a random puppet
        if (!annotation[current_image-1].hasOwnProperty("data")){
            annotation[current_image-1].data = [];
        }     
        var annotate = annotation[current_image-1].data;
            
        annotate.head = {x:280,y:240};
        annotate.body = {x:280,y:260};
        annotate.larm = {x:260,y:255};
        annotate.rarm = {x:300,y:255};
        annotate.lleg = {x:260,y:275};
        annotate.rleg = {x:300,y:275};
        annotate.tail = {x:280,y:280};
        annotate.mtail = {x:280,y:290};
        curve( annotate, "hsb(0, .75, .75)");
        console.log('here');
    });

    set_frame(1);

        // this should give you access to the precomputed flow.
        /* commenting it out for now as we are not using optical flow now- Umang 
        var img = new image()
        var c = document.createelement("canvas")
        img.src = sprintf( flow_path, 1);
        img.onload = function() {
            c.width = img.width;
            c.height = img.height;
            var w = img.width, h = img.height;
            var ctx = c.getcontext("2d");
            ctx.drawimage(img, 0, 0);
            var idata = ctx.getimagedata(0, 0, img.width, img.height);
            var p     = idata.data;
            var lidx;
            var r, g, b, alpha;
            // loop through image pixels
            for (var y=0; y<img.height; y++) {
                for (var x=0; x<img.width; x++) {
                    l = ( y*w + x ) * 4; // convert to linear index
                    r = p[l];   // red should always be zero
                    g = p[l+1]; // green minus 128 is flow in x
                    b = p[l+2]  //  blue minus 128 is flow in y
                    alpha = p[l+3]; // alpha will always be 255
                }
            }
        }
        */
        </script>





	</body>

 </html>
